5 831 }
5 877 //  readPPM()
5 809     img.type = type;
5 792                      unsigned int wordSizeRowPadding)
5 804         exit(15);
5 798     }
5 913         //  Allocate the pixel array
5 874     return imageOut;
5 795     {
5 851     if ((*cropCornerX + *cropWidth >= imageWidth) ||
5 825             break;
5 821         img.bytesPerPixel = sizeof(float);
5 881 //
5 811     {
5 927                     fscanf(inPPM, "%d%d%d", &theRed, &theGreen, &theBlue);
5 934         }
5 806     ImageStruct img;
5 828     unsigned int effectiveWidth = img.bytesPerRow / img.bytesPerPixel;  
5 813         img.bytesPerPixel = 4;
5 800         wordSizeRowPadding!=8 && wordSizeRowPadding!=16 &&
5 833                       unsigned int imageWidth, unsigned int imageHeight,
5 888 //      be \r characters), while Unix-centric stdio functions don't handle that
5 841     //  Note: since we read into an unsigned int, a negative value would come out
5 842     //  as a large positive value
5 901     {
5 904     }
5 801         wordSizeRowPadding!=32 && wordSizeRowPadding!=64)
5 867     {
5 918         if (isASCII)
5 889 //      character as an end of string.  Of course, all the code written by Unix
5 899     FILE* inPPM = fopen(filePath, "r");
5 848         errorReport(INVALID_CROP_HEIGHT_TYPE, argv[3]);
5 931                     pixelData[index++] = 0xFF;  //  alpha
5 794     if (width<3 || height<3)
5 781         printf("Image type not supported for output\n");
5 802     {
5 879 //  Input:  the image to read
5 890 //      geeks to read PPM will fail miserably if you try to run it on Windows
5 908     int isASCII = getHeaderInfoPPM_PGM_(inPPM, filePath, &fileType,
5 854     
5 883 //      PPM (and its PBM/PGM brethens) is just about the stupidest image
5 787 //---------------------------------------
5 815         
5 872         
5 862     ImageStruct imageOut = newImage(cropWidth, cropHeight, RGBA32_RASTER, 1);
5 835                       unsigned int* cropWidth, unsigned int* cropHeight)
5 843     if ((*cropCornerX >= imageWidth) || (*cropCornerY >= imageHeight))
5 850     //  as a large positive value
5 797         exit(14);
5 935         //  The image is stored in a binary format
5 909                                         &nbRows, &nbCols, &maxVal);
5 814         break;
5 905     //  reset dimensions (just to play it safe)
5 930                     pixelData[index++] = (unsigned char) (valScale*theBlue);
5 898     // --- open file ---
5 859                       unsigned int cropCornerX, unsigned int cropCornerY,
5 922                 unsigned index = 4*i*nbCols;
5 878 //  Goal :  read a 24-bit color image in PPM format (binary or ASCII)
5 868         memcpy((unsigned char*) imageOut.raster + (imageOut.height - i - 1)*imageOut.bytesPerRow,
5 822         break;
5 916         float valScale = (maxVal != 255) ?  255.f/maxVal : 1.f;
5 837     if (sscanf(argv[3], "%u", cropCornerX) != 1)
5 785     return 0;
5 810     switch (type)
5 861 {
5 846         errorReport(INVALID_CROP_WIDTH_TYPE, argv[3]);
5 892 //
5 834                       unsigned int* cropCornerX, unsigned int* cropCornerY,
5 887 //      (if you are working on any other platform other than Unix, there *will*
5 928                     pixelData[index++] = (unsigned char) (valScale*theRed);
5 780     {
5 882 //  Rant:
5 807     img.width = width;
5 819         
5 906     unsigned int nbRows = 0, nbCols = 0, maxVal = 0;
5 805     }
5 816         case GRAY_RASTER:
5 782         return 22;
5 919         {
5 845     if (sscanf(argv[5], "%u", cropWidth) != 1)
5 788 //  Image utility functions.
5 784     
5 891 //      or on a Mac because they simply ignore \r.
5 917         //  The image is stored in an ASCII format
5 826     }
5 920             for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
5 903         exit(FILE_NOT_FOUND);
5 900     if (inPPM == NULL)
5 884 //      file format out there.  Only a Unix programmer could possibly have
5 812         case RGBA32_RASTER:
5 858 ImageStruct cropImage(ImageStruct *imageIn,
5 914         unsigned char* pixelData = (unsigned char*)calloc(4*nbCols*nbRows, 1);
5 876 //----------------------------------------------------------------------
5 926                     int theRed, theGreen, theBlue;
5 852         (*cropCornerY + *cropHeight >= imageHeight))
5 791 ImageStruct newImage(unsigned int width, unsigned int height, ImageType type,
5 820         case FLOAT_RASTER:
5 836 {
5 875 }
5 838         errorReport(INVALID_CROP_X_TYPE, argv[3]);
5 871                cropWidth*imageIn->bytesPerPixel);
5 817         img.bytesPerPixel = 1;
5 873     }
5 783     }
5 840         errorReport(INVALID_CROP_Y_TYPE, argv[3]);
5 832 int extractCropRegion(char* argv[],
5 855     //  Otherwise, all is ok, go back to crop
5 923                 
5 824         default:
5 793 {
5 921             {
5 823         
5 799     if (wordSizeRowPadding!=1 && wordSizeRowPadding!=4 &&
5 907     ImageFileType fileType;
5 853         errorReport(INVALID_CROP_SIZE, NULL);
5 844         errorReport(INVALID_CROP_CORNER, NULL);
5 896     ImageStruct image;
5 847     if (sscanf(argv[6], "%u", cropHeight) != 1)
5 857 }
5 870                                                 + cropCornerX * imageIn->bytesPerPixel,
5 924                 for (unsigned int j = 0; j < nbCols; j++)
5 865     //  So I need to invert the row indices.
5 886 //      binary and ASCII stuff, and obliges you to work around the \r chars
5 790 //---------------------------------------
5 849     //  Note: since we read into an unsigned int, a negative value would come out
5 880 //          the input file name.
5 915         //  We only want to handle values in the [0, 255] range
5 818         break;
5 863     
5 864     //  Beware that the images are stored upside-down from the way we view them,
5 827     img.bytesPerRow = ((img.bytesPerPixel * width + wordSizeRowPadding - 1)/wordSizeRowPadding)*wordSizeRowPadding;
5 856     return 0;
5 789 //  Should be moved to some Image.c file
5 885 //      come up with something that dumb.  It is dumb because it mixes
5 860                       unsigned int cropWidth, unsigned int cropHeight)
5 932                 }
5 808     img.height = height;
5 803         printf("wordSizeRowPadding must be one of: 1, 4, 8, 16, 32, or 64\n");
5 866     for (unsigned int i = 0; i<cropHeight; i++)
5 893 //----------------------------------------------------------------------
5 912     {
5 911     if (fileType == kPPM)
5 796         printf("Image size should be at least 3x3\n");
5 895 {
5 929                     pixelData[index++] = (unsigned char) (valScale*theGreen);
5 869                (unsigned char*) imageIn->raster + (imageIn->height - i - cropCornerY - 1)*imageIn->bytesPerRow
5 786 }   
5 839     if (sscanf(argv[4], "%u", cropCornerY) != 1)
5 829     img.raster = (void*) calloc(height*effectiveWidth, img.bytesPerPixel);
5 830     return img;
5 894 ImageStruct readPPM_PGM(char* filePath)
5 902         printf("File %s not found\n", filePath);
5 910     
5 925                 {
5 933             }
5 897     
