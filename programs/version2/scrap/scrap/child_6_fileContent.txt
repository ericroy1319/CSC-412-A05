6 983                 {
6 1048                         //  binary files.
6 1082     if (filePath == NULL)
6 970             image.raster = pixelData;
6 1059         }
6 964     else    //  kPGM
6 999                     unsigned int index = i*nbCols;
6 1015             image.maxVal = maxVal;
6 1057             printf("Only gray levels up to 16 bits currently supported.\n");
6 1074 //          pointer to the image to write
6 965     {
6 1022             image.raster2D = (void*) r2D;
6 972             image.bytesPerPixel = 1;
6 1036                 }
6 1035                     printf("\n");
6 1039             else
6 959         unsigned char** r2D = (unsigned char**) calloc(nbRows, sizeof(unsigned char*));
6 984                     unsigned int index = i*nbCols;
6 1060     }
6 1044                     
6 1027                 {
6 1063     
6 1085         return FILE_PATH_NULL;
6 1055         else
6 940                 unsigned index = 4*i*nbCols;
6 945                     fscanf(inPPM, "%c%c%c", &cRed, &cGreen, &cBlue);
6 1069 }
6 1006             }
6 1075 //
6 1030                     for (unsigned int j = 0; j < nbCols; j++, index++)
6 986                     for (unsigned int j = 0; j < nbCols; j++)
6 946                     //  for binary format I don't bother about the scaling
6 1067     
6 1024             if (isASCII)
6 1034                     }
6 1012             unsigned short* pixelData = (unsigned short*)malloc(nbCols*nbRows*2);
6 994             //  The image is stored in a binary format
6 998                 {
6 954         image.type = RGBA32_RASTER;
6 1053             }
6 956         image.bytesPerRow = 4*nbCols;
6 1010         {
6 981             {
6 1061     
6 975             unsigned char** r2D = (unsigned char**) calloc(nbRows, sizeof(unsigned char*));
6 1076 //  Returns: Error code (0 = no error)
6 937         {
6 1073 //  Input:  path to the output file
6 1062     fclose(inPPM);
6 1050                         fscanf(inPPM, "%c%c", vp, vp+1);
6 993             }
6 1046                     {
6 1068     return image;
6 1089     {
6 936         else
6 1023             //  The image is stored in an ASCII format
6 1047                         //  This is really ugly but "%hu" doesn't seem to work with
6 1032 //                      fscanf(inPPM, "%hu", pixelData + index);
6 968             //  Allocate the pixel array
6 962         image.raster2D = (void*) r2D;
6 1003                         fscanf(inPPM, "%c", pixelData + index);
6 1000                     
6 1083     {
6 1016             image.bytesPerPixel = 2;
6 1014             image.type = DEEP_GRAY_RASTER;
6 1070 //----------------------------------------------------------------------
6 1051                     }
6 996             {
6 1052                 }
6 969             unsigned char* pixelData = (unsigned char*)calloc(nbCols*nbRows, 1);
6 991                     }
6 1045                     for (unsigned j = 0; j < nbCols; j++, index++)
6 966         if (maxVal == 255)
6 938             for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
6 1007         }
6 1011             //  Allocate the pixel array
6 1056         {
6 939             {
6 953         }
6 1090         printf("Error in writePPM: couldn't write to file %s\n", filePath);
6 943                 {
6 971             image.type = GRAY_RASTER;
6 1026                 for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
6 960         for (unsigned int i=0; i<nbRows; i++)
6 958         //  Allocate raster2D
6 1042                 {
6 1071 //  writePPM_PGM()
6 1078 //  Note: Apparently PPM image files are always written upside-down
6 985                     
6 1058             exit(WRONG_FILE_TYPE);
6 974             //  Allocate raster2D
6 1091         return CANNOT_OPEN_WRITE_FILE;
6 1017             image.bytesPerRow = 2*nbCols;
6 947                     pixelData[index++] = (unsigned char) cRed;
6 1013             image.raster = pixelData;
6 1041                 for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
6 1040             {
6 944                     char cRed, cGreen, cBlue;
6 1033                         fscanf(inPPM, "%hu", r2D[i] + j);
6 1066     image.height = nbRows;
6 1031                     {
6 1020             for (unsigned int i=0; i<nbRows; i++)
6 941                 
6 961             r2D[i] = pixelData + i*image.bytesPerRow;
6 1054         }
6 976             for (unsigned int i=0; i<nbRows; i++)
6 997                 for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
6 1008         //  Up to 16 bits of gray levels
6 1009         else if (maxVal  < 65536)
6 980             if (isASCII)
6 1005                 }
6 992                 }
6 955         image.bytesPerPixel = 4;
6 979             //  The image is stored in an ASCII format
6 1064     //  Copy the information into the image struct
6 1002                     {
6 957         image.raster = pixelData;
6 1037             }
6 973             image.bytesPerRow = nbCols;
6 1018             //  Allocate raster2D
6 1004                     }
6 1080 ImageIOErrorCode writePPM_PGM(char* filePath, ImageStruct* img)
6 989                         fscanf(inPPM, "%d", &grayVal);
6 1019             unsigned short** r2D = (unsigned short**) calloc(nbRows, sizeof(unsigned short*));
6 1084         printf("Error in writePPM: file name == NULL\n");
6 982                 for (unsigned int i = nbRows-1, invI = 0; invI < nbRows; i--, invI++)
6 1038             //  The image is stored in a binary format
6 1081 {
6 995             else
6 1025             {
6 1021                 r2D[i] = pixelData + i*nbCols;
6 951                 }
6 967         {
6 1088     if (fp == NULL)
6 978             image.raster2D = (void*) r2D;
6 977                 r2D[i] = pixelData + i*image.bytesPerRow;
6 1065     image.width = nbCols;
6 1077 //
6 1029                     
6 1087     FILE* fp = fopen(filePath, "wb");
6 988                         int grayVal;
6 952             }
6 1079 //----------------------------------------------------------------------
6 990                         pixelData[index++] = (unsigned char) (grayVal);
6 1072 //  Goal :  writes an image in PPM or PGM binary format
6 948                     pixelData[index++] = (unsigned char) cGreen;
6 1049                         char* vp = (char*) (r2D[i] + j);
6 942                 for (unsigned j = 0; j < nbCols; j++)
6 1086     }
6 1001                     for (unsigned j = 0; j < nbCols; j++, index++)
6 987                     {
6 949                     pixelData[index++] = (unsigned char) cBlue;
6 950                     pixelData[index++] = 0xFF;  //  alpha
6 963     }
6 1043                     unsigned index = i*nbCols;
6 1028                     unsigned index = i*nbCols;
