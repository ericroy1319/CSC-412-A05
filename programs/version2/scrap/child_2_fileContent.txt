2 314 ImageStruct rotateImage270(ImageStruct* image);
2 456     //  First, find the start of the input file's name.  Start from the end
2 412     
2 344     char* outImagePath = produceOutFilePath(inputImagePath, outFolderPath, rot);
2 442 }
2 370         break;
2 397         default:
2 388         case ROTATE_270:
2 367             writeTGA(outImagePath, &outImage);
2 383             writeTGA(outImagePath, &outImage);
2 431             *rotVal = (*rotVal + NUM_ROTATIONS - 1) % NUM_ROTATIONS;
2 454     // Produce the name of the output file
2 337     if (err)
2 326 {
2 389         {
2 372         case ROTATE_90:
2 417     *rotVal = NO_ROTATION;
2 461     
2 432             break;
2 451 char* produceOutFilePath(char* inputImagePath, char* outFolderPath,
2 423         {
2 384             free(outImage.raster);
2 335     RotationVal rot;
2 436                 return INVALID_ROT_STRING;
2 393         }
2 428             
2 350     //  fairly close to the behavior of
2 396         //  do shut warnings up
2 455     //-------------------------------------
2 458     unsigned long k = strlen(inputImagePath) - 5;
2 449     exit(code);
2 342     
2 382             ImageStruct outImage = rotateImage180(&image);
2 433             
2 450 }
2 444 {
2 328     if (argc != 4)
2 402     free(image.raster);
2 434             //  anything else is an error
2 407 ImageIOErrorCode determineRotation(char* rotStr, RotationVal* rotVal)
2 377         }
2 357     //              newImage = new ImageClass(...);
2 410     if (rotStr[0] != '-')
2 466     //  If outFolderPath didn't end with a slash, add it
2 440     
2 409     //  string should start with a dash
2 312  *  @return a new image struct that stores the rotated image
2 317 #pragma mark Function implementations
2 340     //  Read the image
2 394         break;
2 333     char* outFolderPath = argv[3];
2 353     //              newImage = new ImageClass(...);
2 406 }
2 414     if (strlen(rotStr) < 2)
2 339     
2 348     //  It would be different if I was returning a pointer to a heap-allocated struct.
2 465     strcpy(outFilePath, outFolderPath);
2 360     //  same code within the cases of my sitch statement
2 437                 
2 385         }
2 379         
2 424             case 'r':
2 448         printf("%s\n", ERROR_STR[code]);
2 443 void errorReport(ImageIOErrorCode code, char* input)
2 321 //        {rotation} inputImagePath outFolderPath
2 343     //  Produce the path to the output image
2 327     //  we need at least one argument
2 375             writeTGA(outImagePath, &outImage);
2 387         
2 463     char* outFilePath = (char*) malloc(strlen(outFolderPath) +
2 336     int err = determineRotation(argv[1], &rot);
2 398             break;
2 345     
2 319 //--------------------------------------------------------------
2 392             free(outImage.raster);
2 355     //      C++:    ImageClas* newImage;    //  pointer to ImageClass object
2 320 //  Main function, expecting as arguments:
2 386         break;
2 460         k--;
2 420     for (unsigned int k=1; k<strlen(rotStr); k++)
2 427             break;
2 322 //  e.g.    l ../Images/cells.tga ../Output
2 408 {
2 325 int main(int argc, char* argv[])
2 363     {
2 364         case NO_ROTATION:
2 381         {
2 347     //  I cannot separate declaration and initialization of my rotated image.
2 403     free(outImagePath);
2 331     //  Just to look prettier in the code, I give meaningful names to my arguments
2 374             ImageStruct outImage = rotateImage90(&image);
2 376             free(outImage.raster);
2 413     //  string should have characters besides the dash
2 351     //      Java:   ImageClass newImage;    //  reference to ImageClass object
2 330     
2 452                          RotationVal rotVal)
2 356     //              ...
2 332     char* inputImagePath = argv[2];
2 399     }
2 366             ImageStruct outImage = copyImage(&image);
2 459     while ((k>=1) && (inputImagePath[k-1] != '/'))
2 411         return NO_DASH_ON_ROT_STRING;
2 378         break;
2 313  */
2 422         switch (rotStr[k])
2 354     //
2 316 #pragma mark -
2 361     //  The code for each case must be between braces because I declare variables within.
2 404     
2 380         case ROTATE_180:
2 430             case 'L':
2 457     //  and move left until we hit the first slash or the left end of the string.
2 390             ImageStruct outImage = rotateImage270(&image);
2 346     //  The way my newImage function is set up (it returns an ImageStruct as value),
2 334     //  Interpret the rotation argument
2 415         return INVALID_ROT_STRING;
2 453 {
2 365         {
2 329         errorReport(WRONG_NUMBER_OF_ARGUMENTS, NULL);
2 400     
2 369         }
2 435             default:
2 447     else
2 405     return 0;
2 368             free(outImage.raster);
2 358     //
2 441     return NO_ERROR;
2 425             case 'R':
2 338         errorReport(err, argv[1]);
2 446         printf("%s: %s\n", ERROR_STR[code], input);
2 341     ImageStruct image = readTGA(inputImagePath);
2 445     if (input != NULL)
2 315 #if 0
2 464                                        strlen(ROT_SUFFIX[rotVal]) + 5);
2 401     //  Cleanup and terminate
2 416     
2 391             writeTGA(outImagePath, &outImage);
2 438         }
2 421     {
2 362     switch(rot)
2 318 #endif
2 462     //  The +5 below is for the length of ".tga" plus the final string-terminating \0
2 349     //  That would get closer to "object-oriented C" in the sense that it would get
2 395         
2 426             *rotVal = (*rotVal + 1) % NUM_ROTATIONS;
2 323 //  It returns an error code (0 for no error)
2 418     //  Iterate through the string, keep the count of poisitive and
2 467     if (outFolderPath[strlen(outFolderPath)-1] != '/')
2 324 //--------------------------------------------------------------
2 429             case 'l':
2 373         {
2 371         
2 359     //  Here, I have no choice but to have slighly different copies of basically the
2 352     //              ...
2 439     }
2 419     //  negative rotations
