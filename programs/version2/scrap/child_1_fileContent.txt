1 246 ImageIOErrorCode determineRotation(char* rotStr, RotationVal* rotVal);
1 209  */
1 157     unsigned short maxVal;
1 284  *  @param  cropWidth       width of the crop region
1 285  *  @param  cropHeight      height of the top region
1 196 #pragma mark -
1 282  *  @param  cropCornerY     y coordinate of the upper-left corner of the crop region
1 242  *  @param  rotStr  the rotation-specifying string in the form -[r|l]+
1 241  *  rotation to apply.
1 213  *  @param  img     pointer to the ImageStruct of the image to write into a .ppm or .pgm file.
1 280  *  @param  image           the image to crop
1 264  */
1 299  *  @param  image   pointer to the RGBA32_RASTER image to rotate
1 297 /** Produces a rotated copy of the input image (rotated by 90 degree clockwise).
1 278                       unsigned int* cropWidth, unsigned int* cropHeight);
1 273  *  @return     an error code (0 if no error)
1 175      *  <ul>
1 205  *  (<tt>.ppm</tt> or <tt>.pgm</tt>) file format. If the image cannot be read (file not found, 
1 198 #endif
1 270  *  @param  cropCornerY     y coordinate of crop region's corner
1 180      *  </ul>
1 171     unsigned int bytesPerRow;
1 262  *  @param rotVal           the rotation applied
1 156      */
1 252  *  @param input    the input string that caused the error (NULL otherwise)
1 164     /** Pixel depth
1 300  *  @return a new image struct that stores the rotated image
1 197 #pragma mark Function prototypes
1 214  *  @return error code indicating whether the image was read successfully or not.
1 166     unsigned int bytesPerPixel;
1 188      *      <li><tt>(int**) raster</tt></li>
1 183     /* Similarly here the 2D raster was cast to a void* pointer
1 268  *  @param  argv    list of input argument to the program
1 220  *  @param  type    one of RGBA32_RASTER, GRAY_RASTER, or FLOAT_RASTER
1 290                       unsigned int cropWidth, unsigned int cropHeight);
1 215  */
1 277                       unsigned int* cropCornerX, unsigned int* cropCornerY,
1 170      */
1 163     unsigned int width;
1 174      *  proper type, e.g.
1 253  */
1 305  *  @param  image   pointer to the RGBA32_RASTER image to rotate
1 249  *  write to a log and "swallow" some non-critical errors.
1 239 int writeTGA(char* filePath, ImageStruct* info);
1 223  *          if you intend to use OpenGL to render the image.
1 288 ImageStruct cropImage(ImageStruct *image,
1 221  *  @param  wordSizeRowPadding word size at which rows should be rounded up.
1 176      *      <li><tt>(int*) raster</tt></li>
1 172     /** Pointer to the image data, cast to a void* pointer.  To
1 185      *  <ul>
1 160     unsigned int height;
1 181      */
1 159      */
1 292  *  This function currently only works for RGBA32_RASTER images.
1 199 //  Reads the header of a PPM/PGM file
1 216 ImageIOErrorCode writePPM_PGM(char* filePath, ImageStruct* img);
1 301  */
1 251  *  @param code     the code of the error to report/process
1 298  *  This function currently only works for RGBA32_RASTER images.
1 247 /** In this app, just prints out an error message to the console and
1 192     void* raster2D;
1 289                       unsigned int cropCornerX, unsigned int cropCornerY,
1 231  *  @return  a properly initialized ImageStruct storing the image read
1 232  */
1 281  *  @param  cropCornerX     x coordinate of the upper-left corner of the crop region
1 200 char getHeaderInfoPPM_PGM_(FILE* inPPM, char* filePath,
1 309 /** Produces a rotated copy of the input image (rotated by 270 degree clockwise).
1 158     /** Number of rows (height) of the image
1 286  *  @return     the new image resulting from applying the crop
1 173      *  access the data, you would have to cast the pointer to the
1 224  */
1 311  *  @param  image   pointer to the RGBA32_RASTER image to rotate
1 228  *  (<tt>.tga</tt>) file format. If the image cannot be read (file not found, invalid format, etc.)
1 165      */
1 236  *  @param  info        pointer to the ImageStruct of the image to write into a .tga file.
1 219  *  @param  height  number of rows of the image
1 275 int extractCropRegion(char* argv[],
1 235  *  @param  filePath    path to the file to write
1 303 /** Produces a rotated copy of the input image (rotated by 180 degree clockwise).
1 212  *  @param  filePath    path to the file to write
1 217 /** returns a properly initialized ImageStruct (including the 1D raster).
1 293  *  @param  image   pointer to the RGBA32_RASTER image to copy
1 260  *  @param inputImagePath   path to the input image
1 276                       unsigned int imageWidth, unsigned int imageHeight,
1 184      *  and would need to be cast back to the proper type to be used, e.g.
1 233 ImageStruct readTGA(char* filePath);
1 266                          RotationVal rotVal);
1 161     /** Number of columns (width) of the image
1 255 /** Produces a complete path to the output image file.
1 169      *  word length (e.g. multiple of 16 or 32))
1 259  *
1 291 /** Produces a copy of the input image (rotation by 0).
1 254 void errorReport(ImageIOErrorCode code, char* input);
1 272  *  @param  cropHeight      crop region's height
1 201                            ImageFileType* fileType,
1 238  */
1 234 /** Writes an image file in the <b>uncompressed</b>, un-commented TARGA (<tt>.tga</tt>) file format.
1 189      *      <li><tt>(float**) raster</tt></li>
1 193     
1 222  *          You should use a padding size of 4 for a GRAY_RASTER raster
1 261  *  @param outFolderPath    path to the output folder
1 162      */
1 195 #if 0
1 279 /** Produces a new image that is a cropped part of the input image
1 245  */
1 225 ImageStruct newImage(unsigned int width, unsigned int height, ImageType type,
1 207  *  @param  filePath    path to the file to read
1 194 } ImageStruct;
1 310  *  This function currently only works for RGBA32_RASTER images.
1 227 /** No-frills function that reads an image file in the <b>uncompressed</b>, un-commented TARGA 
1 203                            unsigned int* maxVal);
1 226                      unsigned int wordSizeRowPadding);
1 167     /** Number of bytes per row (which may be larger than
1 302 ImageStruct rotateImage90(ImageStruct* image);
1 168      *  bytesPerPixel * nbCols if rows are padded to a particular
1 283  *                          (counted from the top, so height - row index - 1
1 269  *  @param  cropCornerX     x coordinate of crop region's corner
1 287  */
1 179      *      <li><tt>(float*) raster</tt></li>
1 256  *  If the input file path was ../../Images/clown and the 90-degree-rotated is to be
1 208  *  @return  a properly initialized ImageStruct storing the image read
1 211 /** Writes an image file in the PPM/PGM (<tt>.ppm</tt> or <tt>.pgm</tt>) file format.
1 263  *  @return complete path to the desired output file.
1 244  *  @return an error code
1 294  *  @return a new image struct that stores a copy of the input image
1 248  *  exits with the proper error code.  In a fancier version, could
1 296 ImageStruct copyImage(ImageStruct* image);
1 182     void* raster;
1 265 char* produceOutFilePath(char* inputImagePath, char* outFolderPath,
1 271  *  @param  cropWidth       crop region's width
1 210 ImageStruct readPPM_PGM(char* filePath);
1 243  *  @param  rotVal  pointer to a RotationVal enum variable
1 177      *      <li><tt>(unsigned char*) raster</tt></li>
1 218  *  @param  width   number of columns of the image
1 206  *  invalid format, etc.) the function simply terminates execution.
1 306  *  @return a new image struct that stores the rotated image
1 202                            unsigned int* nbRows, unsigned int* nbCols,
1 257  *  written the output folder path is ../Output [with or without final slash),
1 267 /** interprets the program's input argument to determine the crop region.
1 187      *      <li><tt>(unsigned char**) raster</tt></li>
1 307  */
1 204 /** No-frills function that reads an image file in the <b>uncompressed</b>, un-commented PPM/PGM 
1 295  */
1 229  *  the function simply terminates execution.
1 230  *  @param  filePath    path to the file to read
1 191      */
1 190      *  </ul>
1 186      *      <li><tt>(int**) raster</tt></li>
1 304  *  This function currently only works for RGBA32_RASTER images.
1 240 /** Processes the rotation-specifying string to determine the
1 308 ImageStruct rotateImage180(ImageStruct* image);
1 250  *
1 237  *  @return 1 if the image was read successfully, 0 otherwise.
1 178      *      <li><tt>(int*) raster</tt></li>
1 258  *  then the output file path will be ../Output/clown [r].tga
1 274  */
